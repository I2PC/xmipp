#!/usr/bin/env python3
# ***************************************************************************
# * Authors:		Alberto García (alberto.garcia@cnb.csic.es)
# *							Martín Salinas (martin.salinas@cnb.csic.es)
# *
# *
# * This program is free software; you can redistribute it and/or modify
# * it under the terms of the GNU General Public License as published by
# * the Free Software Foundation; either version 2 of the License, or
# * (at your option) any later version.
# *
# * This program is distributed in the hope that it will be useful,
# * but WITHOUT ANY WARRANTY; without even the implied warranty of
# * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# * GNU General Public License for more details.
# *
# * You should have received a copy of the GNU General Public License
# * along with this program; if not, write to the Free Software
# * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
# * 02111-1307 USA
# *
# * All comments concerning this program package may be sent to the
# * e-mail address 'scipion@cnb.csic.es'
# ***************************************************************************/

# General imports
import argparse, sys, os, multiprocessing
from datetime import datetime
from time import time

# Installer imports
from installer.constants import (MODE_ALL, MODE_COMPILE_AND_INSTALL, MODE_CONFIG, MODE_CLEAN_BIN,\
	MODE_CLEAN_ALL, MODE_CLEAN_DEPRECATED, MODE_VERSION, MODE_GET_MODELS,\
	MODE_TEST, MODE_GIT, MODE_ADD_MODEL, COMMON_USAGE_HELP_MESSAGE, DEFAULT_BUILD_DIR, DEFAULT_MODELS_DIR,
		XMIPP_MODE_ERROR,  DEFAULT_MODE_DEBUG, XMIPP_VERSIONS, LOG_FILE)
from installer.utils import (printError, runJob, addDeepLearningModel,
														 downloadDeepLearningModels, runTests, branchName,
														 getCurrentEnvName, printMessage)
from installer.config.config import config, checkGit
from installer.parser import ModeHelpFormatter, GeneralHelpFormatter, ErrorHandlerArgumentParser
from installer.main import (cleanDeprecated, cleanSources, cleanBin, compileAndInstall)
from installer.versions import collectAllVersions
from installer.exit import exitXmipp


####################### EXECUTION MODES #######################
def modeAddModel(args: argparse.Namespace):
  """
  ### Checks the params for execution mode "addModel" and then runs it.

  #### Params:
  - args (Namespace): Command line arguments parsed by argparse library.
  """
  addDeepLearningModel(login=args.login, modelPath=args.modelPath, update=args.update)

def modeCleanBin(args: argparse.Namespace):
  """
	### Checks the params for execution mode "cleanBin" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
  cleanBin()

def modeCleanAll(args: argparse.Namespace):
	"""
	### Checks the params for execution mode "cleanAll" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	print("WARNING: This will DELETE ALL content from src and build. Notice that if you have unpushed changes, \n"
		" they will be deleted.\nAre you sure you want to do this? (YeS/[No]) -case sensitive-")
	yesno = input()
	if yesno == "YeS":
		cleanSources()
		modeCleanBin(args)
	else:
		print("Clean mode aborted.")

def modeCleanDeprecated(args: argparse.Namespace):
	"""
	### Checks the params for execution mode "cleanDeprecated" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	cleanDeprecated()

def modeCompileAndInstall(args: argparse.Namespace, dictConfig=None):
	"""
	### Checks the params for execution mode "compileAndInstall" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	try:
		os.remove(LOG_FILE)
	except FileNotFoundError:
			pass
	compileAndInstall(argparse.Namespace)

def modeConfig(args: argparse.Namespace):
	"""
	### Checks the params for execution mode "config" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	try:
		os.remove(LOG_FILE)
	except FileNotFoundError:
			pass
	return config(args.debug, scratch=True, tarAndPost=False)

def modeGetModels(args: argparse.Namespace):
	"""
	### Checks the params for execution mode "getModels" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	downloadDeepLearningModels(dest=args.directory)

def modeGit(args: argparse.Namespace):
	"""
	### Checks the params for execution mode "git" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	checkGit()
	print('\n------------------------------------')
	print('-Repository xmippCore:\n', end='')
	retCode, outputStr = runJob("(cd src/xmippCore; git %s)" % " ".join(args.command))
	if retCode == 0:
			print(outputStr)

	print('\n------------------------------------')
	print('-Repository xmipp:\n', end='')
	retCode, outputStr = runJob("(cd src/xmipp; git %s)" % " ".join(args.command))
	if retCode == 0:
			print(outputStr)

	print('\n------------------------------------')
	print('-Repository xmippViz:\n', end='')
	retCode, outputStr = runJob("(cd src/xmippViz; git %s)" % " ".join(args.command))
	if retCode == 0:
			print(outputStr)

	print('\n------------------------------------')
	print('-Repository scipion-em-xmipp:\n', end='')
	retCode, outputStr = runJob("(cd src/scipion-em-xmipp; git %s)" % " ".join(args.command))
	if retCode == 0:
			print(outputStr)

def modeTest(parser, args=argparse.Namespace):
	"""
	### Checks the params for execution mode "test" and then runs it.
	
	#### Params:
	- parser (ErrorHandlerArgumentParser): Parser object used to parse the arguments.
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	# Check if at least either one of the two params has been used
	if not args.show and not args.testName and not args.allPrograms and not args.allFuncs:
		parser.error("At least one flag is required in testing mode. Run \"./xmipp test -h\" to get a list of available flags.")
	dictPackages = config(debugP=False, tarAndPost=False)
	runTests(testName=args.testName, show=args.show, allPrograms=args.allPrograms,
					 allFuncs=args.allFuncs, CUDA=dictPackages['CUDA'])

def modeVersion(args: argparse.Namespace):
  """
  ### Checks the params for execution mode "version" and then runs it.

  #### Params:
  - args (Namespace): Command line arguments parsed by argparse library.
  """
  dictPackages = config(debugP=False, tarAndPost=False)
  dictV = collectAllVersions(dictPackages)
  print(('----------------------------------------'))
  print('Repositories details:')
  currentPath = os.getcwd()
  for key, value in XMIPP_VERSIONS.items():
    os.chdir(currentPath)
    if key !='xmipp':
      os.chdir(os.path.join(currentPath, 'src/{}'.format(key)))
    branch = branchName()
    print('{}: '.format(key))
    print('\t{} (Branch: {})'.format(value['vername'], branch))

  print(('----------------------------------------'))
  print('Package versions:')
  print(('gcc version: \t{}'.format(dictV['gccV'])))
  print(('gpp version: \t{}'.format(dictV['gppV'])))
  print(('mpi version: \t{}'.format(dictV['mpiV'])))
  print(('CUDA version: \t{}'.format(dictV['cudaV'])))
  print(('opencv version:\t{}'.format(dictV['opencvV'])))
  print(('java version: \t{}'.format(dictV['javaV'])))
  print(('scons version: \t{}'.format(dictV['sconsV'])))
  print(('cmake version: \t{}'.format(dictV['cmakeV'])))
  print(('rsync version: \t{}'.format(dictV['rsyncV'])))
  print(('hdf5 version: \t{}'.format(dictV['hdf5V'])))
  print(('tiff version: \t{}'.format(dictV['TIFFVn'])))
  print(('fftw3 version: \t{}'.format(dictV['FFTW3V'])))
  print('\n')

def modeAll(args: argparse.Namespace):
	"""
	### Checks the params for execution mode "all" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	try:
		os.remove(LOG_FILE)
	except FileNotFoundError:
			pass
	envName = getCurrentEnvName()
	dateStart = time()
	printMessage(f"Compilation date: {datetime.today()}", debug=True)
	printMessage(f"Active enviroment: {envName}", debug=True)
	dictConfig = config(debugP=False,tarAndPost=True)
	compileAndInstall(args)
	printMessage(f"Compilation and install time: {round((time() - dateStart) / 60.0, 1)} mins", debug=False)
	printMessage('\n---------------------------------------\n', debug=True)
	if args.NoModels == None:
			downloadDeepLearningModels(args.directory)
	exitXmipp(dictPackages=dictConfig)

def runSelectedMode(parser: ErrorHandlerArgumentParser, args: argparse.Namespace):
	"""
	### This function runs the selected execution mode.

	#### Params:
	- parser (ErrorHandlerArgumentParser): Parser object used to parse the arguments.
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	if args.mode == MODE_ADD_MODEL:
		modeAddModel(args)
	elif args.mode == MODE_ALL:
		modeAll(args)
	elif args.mode == MODE_CLEAN_ALL:
		modeCleanAll(args)
	elif args.mode == MODE_CLEAN_BIN:
		modeCleanBin(args)
	elif args.mode == MODE_CLEAN_DEPRECATED:
		modeCleanDeprecated(args)
	elif args.mode == MODE_COMPILE_AND_INSTALL:
		modeCompileAndInstall(args)
	elif args.mode == MODE_CONFIG:
		modeConfig(args)
	elif args.mode == MODE_GET_MODELS:
		modeGetModels(args)
	elif args.mode == MODE_GIT:
		modeGit(args)
	elif args.mode == MODE_TEST:
		modeTest(parser, args)
	elif args.mode == MODE_VERSION:
		modeVersion(args)
	else:
		# If method was none of the above, exit with error
		printError(f"Mode \"{args.mode}\" not recognized. {COMMON_USAGE_HELP_MESSAGE}")
		exitXmipp(retCode=XMIPP_MODE_ERROR, tarPost=False)


####################### MAIN EXECUTION THREAD #######################
if __name__ == "__main__":
	""" Calls main function when executed. """
	# Defining default jobs
	JOBS = multiprocessing.cpu_count()
	if JOBS <= 18:
			DEFAULT_JOBS = JOBS - 3
	else:
			DEFAULT_JOBS = 16

	# Creating parser to parse the command-line arguments
	parser = ErrorHandlerArgumentParser(formatter_class=GeneralHelpFormatter, prog="xmipp")

	# Adding subparsers to have other variables deppending on the value of the mode
	subparsers = parser.add_subparsers(dest="mode")

	# Arguments for mode 'addModel'
	addModelSubparser = subparsers.add_parser(MODE_ADD_MODEL, formatter_class=ModeHelpFormatter)
	addModelSubparser.add_argument("login")
	addModelSubparser.add_argument("modelPath")
	addModelSubparser.add_argument("update")

	# Arguments for mode 'all'
	allSubparser = subparsers.add_parser(MODE_ALL, formatter_class=ModeHelpFormatter)
	allSubparser.add_argument("-j", "--jobs", type=int, default=DEFAULT_JOBS)
	allSubparser.add_argument("-br", "--branch")
	allSubparser.add_argument("-dir", "--directory", default=DEFAULT_BUILD_DIR)
	allSubparser.add_argument("-NoModels", "--NoModels", action='store_false', default=None)



	# Arguments for mode 'cleanAll'
	cleanAllSubparser = subparsers.add_parser(MODE_CLEAN_ALL, formatter_class=ModeHelpFormatter)

	# Arguments for mode 'cleanBin'
	cleanBinSubparser = subparsers.add_parser(MODE_CLEAN_BIN, formatter_class=ModeHelpFormatter)

	# Arguments for mode 'cleanDeprecated'
	cleanDeprecatedSubparser = subparsers.add_parser(MODE_CLEAN_DEPRECATED, formatter_class=ModeHelpFormatter)

	# Arguments for mode 'compileAndInstall'
	compileAndInstallSubparser = subparsers.add_parser(MODE_COMPILE_AND_INSTALL, formatter_class=ModeHelpFormatter)
	compileAndInstallSubparser.add_argument("-j", "--jobs", type=int, default=DEFAULT_JOBS)
	compileAndInstallSubparser.add_argument("-br", "--branch")
	compileAndInstallSubparser.add_argument("-dir", "--directory", default=DEFAULT_BUILD_DIR)

	# Arguments for mode 'config'
	configSubparser = subparsers.add_parser(MODE_CONFIG, formatter_class=ModeHelpFormatter)
	configSubparser.add_argument("-debug", "--debug", action='store_true', default=DEFAULT_MODE_DEBUG)



	# Arguments for mode 'getModels'
	getModelsSubparser = subparsers.add_parser(MODE_GET_MODELS, formatter_class=ModeHelpFormatter)
	getModelsSubparser.add_argument("-dir", "--directory", default=DEFAULT_MODELS_DIR)

	# Arguments for mode 'git'
	gitSubparser = subparsers.add_parser(MODE_GIT, formatter_class=ModeHelpFormatter)
	gitSubparser.add_argument("command", nargs='+')

	# Arguments for mode 'test'
	testSubparser = subparsers.add_parser(MODE_TEST, formatter_class=ModeHelpFormatter)
	testSubparser.add_argument("testName", nargs='?', default=None)
	testSubparser.add_argument("-show", "--show", action='store_true')
	testSubparser.add_argument("-allPrograms", "--allPrograms", "--allprograms", action='store_true')
	testSubparser.add_argument("-allFuncs", "--allFuncs", "-allfuncs", action='store_true')


	# Arguments for mode 'version'
	versionSubparser = subparsers.add_parser(MODE_VERSION, formatter_class=ModeHelpFormatter)
	versionSubparser.add_argument("-short", "--short", action='store_true')

	# Applying default mode value if needed
	if len(sys.argv) == 1 or (
		len(sys.argv) > 1 and 
		sys.argv[1].startswith('-') and 
		'-h' not in sys.argv and
		'--help' not in sys.argv):
		sys.argv.insert(1, MODE_ALL)

	# Parse arguments
	args = parser.parse_args()

	# Error control for number of jobs
	if hasattr(args, 'jobs') and args.jobs < 1:
		parser.error(f"Wrong job number \"{args.jobs}\". Number of jobs has to be 1 or greater.")
	
	# Error control for branch
	if hasattr(args, "branch") and args.branch is not None and len(args.branch.split(' ')) > 1:
		parser.error(f"Incorrect branch name \"{args.branch}\". Branch names can only be one word long.")

	# Running always under this own directory.
	os.chdir(os.path.dirname(os.path.abspath(__file__)))

	# Running installer in selected mode
	runSelectedMode(parser, args)
