#!/usr/bin/env python3
# ***************************************************************************
# * Authors:		Alberto García (alberto.garcia@cnb.csic.es)
# *							Martín Salinas (martin.salinas@cnb.csic.es)
# *
# *
# * This program is free software; you can redistribute it and/or modify
# * it under the terms of the GNU General Public License as published by
# * the Free Software Foundation; either version 2 of the License, or
# * (at your option) any later version.
# *
# * This program is distributed in the hope that it will be useful,
# * but WITHOUT ANY WARRANTY; without even the implied warranty of
# * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# * GNU General Public License for more details.
# *
# * You should have received a copy of the GNU General Public License
# * along with this program; if not, write to the Free Software
# * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
# * 02111-1307 USA
# *
# * All comments concerning this program package may be sent to the
# * e-mail address 'scipion@cnb.csic.es'
# ***************************************************************************/

# General imports
import argparse, sys, os, multiprocessing
from typing import Dict

# Installer imports
from installer.constants import (MODE_ALL, MODE_COMPILE_AND_INSTALL, MODE_CONFIG, MODE_CLEAN_BIN,
	MODE_CLEAN_ALL, MODE_VERSION, MODE_GET_MODELS, MODE_TEST, MODE_GIT, MODE_ADD_MODEL,
	COMMON_USAGE_HELP_MESSAGE, DEFAULT_BUILD_DIR, DEFAULT_MODELS_DIR, CONFIG_FILE,
	CMAKE_CONFIGURE_ERROR, CMAKE_COMPILE_ERROR, CMAKE_INSTALL_ERROR, PARAM_LOGIN, PARAM_SHORT,
	PARAM_JOBS, PARAM_BRANCH, PARAM_GIT_COMMAND, PARAM_MODEL_PATH, PARAM_MODELS_DIRECTORY,
	PARAM_SHOW_TESTS, PARAM_TEST_NAME, PARAM_UPDATE, PARAM_XMIPP_DIRECTORY, BUILD_PATH,
	INSTALL_PATH, BUILD_TYPE, SOURCES_PATH, XMIPP_SOURCES, XMIPP, LOG_FILE, CMAKE_ERROR)
from installer.utils import runStreamingJob, runJob
from installer.parser import ModeHelpFormatter, GeneralHelpFormatter, ErrorHandlerArgumentParser, getParamNames
from installer.config import readConfig, writeConfig, getCMake, isCMakeValid
from installer.main import getCMakeVarsStr, getSources, exitXmipp, handleRetCode, getSectionMessage, getSuccessMessage
from installer.logger import logger, yellow, red, blue

####################### EXECUTION MODES #######################
def modeAddModel(args: argparse.Namespace):
	"""
	### Checks the params for execution mode "addModel" and then runs it.

	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	pass

def modeCleanBin():
	"""
	### Checks the params for execution mode "cleanBin" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	runJob(f"find {SOURCES_PATH}/* -name \"*.so\" -exec rm -rf {{}} \;", showCommand=True, logOutput=False)
	runJob(f"find {SOURCES_PATH}/* -name \"*.os\" -exec rm -rf {{}} \;", showCommand=True, logOutput=False)
	runJob(f"find {SOURCES_PATH}/* -name \"*.o\" -exec rm -rf {{}} \;", showCommand=True, logOutput=False)
	runJob("find . -iname \"*.pyc\" -delete", showCommand=True, logOutput=False)
	runJob(f"rm -rf {CONFIG_FILE} {BUILD_PATH}", showCommand=True, logOutput=False)
	runJob("find . -iname \"*.dblite\" -delete", showCommand=True, logOutput=False)
	runJob(f"find {os.path.join(SOURCES_PATH, XMIPP, 'applications', 'programs')} --type d -empty", showCommand=True, logOutput=False)

def modeCleanAll():
	"""
	### Checks the params for execution mode "cleanAll" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	# Print warning text and await input
	confirmationText = 'YeS'
	warningStr = "WARNING: This will DELETE ALL content from src and build.\n"
	warningStr += "\tNotice that if you have unpushed changes, they will be deleted.\n"
	warningStr += f"\nIf you are sure you want to do this, type '{confirmationText}' (case sensitive):"
	print(yellow(warningStr))

	try:
		userInput = input()
	except KeyboardInterrupt:
		userInput = ''
		print("")
	if userInput == confirmationText:
		# Get xmipp sources
		xmippSources = [os.path.join(SOURCES_PATH, source) for source in XMIPP_SOURCES]
		runJob(f"rm -rf {BUILD_PATH} {INSTALL_PATH} {' '.join(xmippSources)} {CONFIG_FILE}", showCommand=True, logOutput=False)
	else:
		print(red("Operation cancelled."))

def modeCompileAndInstall(args: argparse.Namespace, configDict: Dict={}) -> Dict:
	"""
	### Checks the params for execution mode "compileAndInstall" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	- configDict (dict): Optional. If provided, it will use it's variables. If not, it will read from config file.

	#### Returns:
	- (dict): Dictionary containig all config variables.
	"""
	# If config variable dictionary is not received this mode is the first being executed
	if not configDict:
		logger.startLogFile(LOG_FILE)
		configDict = readConfig(CONFIG_FILE)
		if not isCMakeValid(configDict=configDict):
			handleRetCode(CMAKE_ERROR, predefinedErrorCode=CMAKE_ERROR)

	# Compile with CMake
	cmakeExecutable = getCMake(configDict)
	logger(getSectionMessage("Compiling with CMake"), forceConsoleOutput=True)
	retCode, output = runStreamingJob(f"{cmakeExecutable} --build {BUILD_PATH} --config {BUILD_TYPE} -j {args.jobs}",
													 showOutput=True, substitute=True)
	handleRetCode(retCode, predefinedErrorCode=CMAKE_COMPILE_ERROR, configDict=configDict, message=output)
	
	# Install with CMake
	logger(getSectionMessage("Installing with CMake"), forceConsoleOutput=True)
	retCode, output = runStreamingJob(f"{cmakeExecutable} --install {BUILD_PATH} --config {BUILD_TYPE} --prefix {INSTALL_PATH}",
													 showOutput=True, substitute=True)
	handleRetCode(retCode, predefinedErrorCode=CMAKE_INSTALL_ERROR, configDict=configDict, message=output)
	
	return configDict

def modeConfig(overwrite: bool=False) -> Dict:
	"""
	### Checks the params for execution mode "config" and then runs it.
	
	#### Params:
	- overwrite (bool): If True, file is created from scratch with default values.

	#### Returns:
	- (dict): Dictionary containig all config variables.
	"""
	if overwrite or not os.path.exists(CONFIG_FILE):
		writeConfig(CONFIG_FILE)
	
	return readConfig(CONFIG_FILE)

def modeGetModels(args: argparse.Namespace):
	"""
	### Checks the params for execution mode "getModels" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	pass

def modeGit(args: argparse.Namespace):
	"""
	### Checks the params for execution mode "git" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	cmd = f"git {' '.join(args.command)}"
	print(f"Running command '{cmd}' for all xmipp sources...")
	for source in XMIPP_SOURCES:
		print("")
		# Check if source exists to perform command, else skip
		sourcePath = os.path.abspath(os.path.join(SOURCES_PATH, source))
		if not os.path.exists(sourcePath):
			print(yellow(f"WARNING: Source {source} does not exist in path {sourcePath}. Skipping."))
			continue
		print(blue(f"Running command for {source} in path {sourcePath}..."))
		runJob(cmd, logOutput=False, cwd=sourcePath, showOutput=True, showError=True)

def modeTest(parser, args=argparse.Namespace):
	"""
	### Checks the params for execution mode "test" and then runs it.
	
	#### Params:
	- parser (ErrorHandlerArgumentParser): Parser object used to parse the arguments.
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	pass

def modeVersion(args: argparse.Namespace):
	"""
	### Checks the params for execution mode "version" and then runs it.

	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	pass

def modeAll(args: argparse.Namespace) -> Dict:
	"""
	### Checks the params for execution mode "all" and then runs it.
	
	#### Params:
	- args (Namespace): Command line arguments parsed by argparse library.

	#### Returns:
	- (dict): Dictionary containig all config variables.
	"""
	# Initiate logger
	logger.startLogFile(LOG_FILE)

	# Read and/or write variables from config file
	configDict = modeConfig()

	# Check if cmake is valid
	if not isCMakeValid(configDict=configDict):
		handleRetCode(CMAKE_ERROR, predefinedErrorCode=CMAKE_ERROR)

	# Clone sources from specified branch
	getSources(branch=args.branch)

	# Configure with CMake
	cmakeExecutable = getCMake(configDict)
	logger(getSectionMessage("Configuring with CMake"), forceConsoleOutput=True)
	configureCmd = f"{cmakeExecutable} -S . -B {BUILD_PATH} -D CMAKE_INSTALL_PREFIX={INSTALL_PATH}"
	configureCmd += f" -D CMAKE_BUILD_TYPE={BUILD_TYPE} {getCMakeVarsStr(configDict)}"
	retCode, output = runStreamingJob(configureCmd, showOutput=True, substitute=True)
	handleRetCode(retCode, predefinedErrorCode=CMAKE_CONFIGURE_ERROR, configDict=configDict, message=output)

	# Compile and install
	return modeCompileAndInstall(args, configDict=configDict)

def runSelectedMode(parser: ErrorHandlerArgumentParser, args: argparse.Namespace):
	"""
	### This function runs the selected execution mode.

	#### Params:
	- parser (ErrorHandlerArgumentParser): Parser object used to parse the arguments.
	- args (Namespace): Command line arguments parsed by argparse library.
	"""
	configDict = {}
	if args.mode == MODE_ADD_MODEL:
		modeAddModel(args)
	elif args.mode == MODE_ALL:
		configDict = modeAll(args)
	elif args.mode == MODE_CLEAN_ALL:
		modeCleanAll()
	elif args.mode == MODE_CLEAN_BIN:
		modeCleanBin()
	elif args.mode == MODE_COMPILE_AND_INSTALL:
		configDict = modeCompileAndInstall(args)
	elif args.mode == MODE_CONFIG:
		modeConfig(overwrite=True)
	elif args.mode == MODE_GET_MODELS:
		modeGetModels(args)
	elif args.mode == MODE_GIT:
		modeGit(args)
	elif args.mode == MODE_TEST:
		modeTest(parser, args)
	elif args.mode == MODE_VERSION:
		modeVersion(args)
	else:
		# If method was none of the above, exit with error
		logger.logError(f"Mode \"{args.mode}\" not recognized. {COMMON_USAGE_HELP_MESSAGE}")
		exitXmipp(retCode=1, configDict=configDict)
	
	# Print success message for specific modes
	if args.mode == MODE_ALL or args.mode == MODE_COMPILE_AND_INSTALL:
		logger(getSuccessMessage(), forceConsoleOutput=True)
	exitXmipp(configDict=configDict)
	
####################### MAIN EXECUTION THREAD #######################
if __name__ == "__main__":
	""" Calls main function when executed. """
	# Defining default jobs
	JOBS = multiprocessing.cpu_count()

	# Creating parser to parse the command-line arguments
	parser = ErrorHandlerArgumentParser(formatter_class=GeneralHelpFormatter, prog="xmipp")

	# Adding subparsers to have other variables deppending on the value of the mode
	subparsers = parser.add_subparsers(dest="mode")

	# Arguments for mode 'addModel'
	addModelSubparser = subparsers.add_parser(MODE_ADD_MODEL, formatter_class=ModeHelpFormatter)
	addModelSubparser.add_argument(*getParamNames(PARAM_LOGIN))
	addModelSubparser.add_argument(*getParamNames(PARAM_MODEL_PATH))
	addModelSubparser.add_argument(*getParamNames(PARAM_UPDATE), action='store_true')

	# Arguments for mode 'all'
	allSubparser = subparsers.add_parser(MODE_ALL, formatter_class=ModeHelpFormatter)
	allSubparser.add_argument(*getParamNames(PARAM_JOBS), type=int, default=JOBS)
	allSubparser.add_argument(*getParamNames(PARAM_BRANCH))
	allSubparser.add_argument(*getParamNames(PARAM_XMIPP_DIRECTORY), default=DEFAULT_BUILD_DIR)

	# Arguments for mode 'cleanAll'
	cleanAllSubparser = subparsers.add_parser(MODE_CLEAN_ALL, formatter_class=ModeHelpFormatter)

	# Arguments for mode 'cleanBin'
	cleanBinSubparser = subparsers.add_parser(MODE_CLEAN_BIN, formatter_class=ModeHelpFormatter)

	# Arguments for mode 'compileAndInstall'
	compileAndInstallSubparser = subparsers.add_parser(MODE_COMPILE_AND_INSTALL, formatter_class=ModeHelpFormatter)
	compileAndInstallSubparser.add_argument(*getParamNames(PARAM_JOBS), type=int, default=JOBS)
	compileAndInstallSubparser.add_argument(*getParamNames(PARAM_BRANCH))
	compileAndInstallSubparser.add_argument(*getParamNames(PARAM_XMIPP_DIRECTORY), default=DEFAULT_BUILD_DIR)

	# Arguments for mode 'config'
	configSubparser = subparsers.add_parser(MODE_CONFIG, formatter_class=ModeHelpFormatter)

	# Arguments for mode 'getModels'
	getModelsSubparser = subparsers.add_parser(MODE_GET_MODELS, formatter_class=ModeHelpFormatter)
	getModelsSubparser.add_argument(*getParamNames(PARAM_MODELS_DIRECTORY), default=DEFAULT_MODELS_DIR)

	# Arguments for mode 'git'
	gitSubparser = subparsers.add_parser(MODE_GIT, formatter_class=ModeHelpFormatter)
	gitSubparser.add_argument(*getParamNames(PARAM_GIT_COMMAND), nargs='+')

	# Arguments for mode 'test'
	testSubparser = subparsers.add_parser(MODE_TEST, formatter_class=ModeHelpFormatter)
	testSubparser.add_argument(*getParamNames(PARAM_TEST_NAME), nargs='?', default=None)
	testSubparser.add_argument(*getParamNames(PARAM_SHOW_TESTS), action='store_true')

	# Arguments for mode 'version'
	versionSubparser = subparsers.add_parser(MODE_VERSION, formatter_class=ModeHelpFormatter)
	versionSubparser.add_argument(*getParamNames(PARAM_SHORT), action='store_true')

	# Applying default mode value if needed
	if len(sys.argv) == 1 or (
		len(sys.argv) > 1 and 
		sys.argv[1].startswith('-') and 
		'-h' not in sys.argv and
		'--help' not in sys.argv):
		sys.argv.insert(1, MODE_ALL)

	# Parse arguments
	args = parser.parse_args()

	# Error control for number of jobs
	if hasattr(args, 'jobs') and args.jobs < 1:
		parser.error(f"Wrong job number \"{args.jobs}\". Number of jobs has to be 1 or greater.")
	
	# Error control for branch
	if hasattr(args, "branch") and args.branch is not None and len(args.branch.split(' ')) > 1:
		parser.error(f"Incorrect branch name \"{args.branch}\". Branch names can only be one word long.")

	# Running always under this own directory.
	os.chdir(os.path.dirname(os.path.abspath(__file__)))

	# Running installer in selected mode
	runSelectedMode(parser, args)
