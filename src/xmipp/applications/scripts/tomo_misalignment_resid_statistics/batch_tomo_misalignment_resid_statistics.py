"""
/***************************************************************************
 *
 * Authors:    Federico P. de Isidro Gomez			  fp.deisidro@cnb.csic.es
 *
 * Unidad de  Bioinformatica of Centro Nacional de Biotecnologia , CSIC
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 * 02111-1307  USA
 *
 *  All comments concerning this program package may be sent to the
 *  e-mail address 'xmipp@cnb.csic.es'
 ***************************************************************************/
"""


import re
from xmipp_base import *
import xmippLib
  
import sys
import os
from math import sqrt
from statsmodels.tsa.stattools import adfuller
from scipy import stats
import numpy as np


class ScriptTomoResidualStatistics(XmippScript):

  def __init__(self):
    XmippScript.__init__(self)

    self.p = 0.5
    self.residSize = {}
    self.residX = {}
    self.residY = {}
    self.residXAcc = {}
    self.residYAcc = {}
    self.moduleAcc = {}
    self.nPosX = {}
    self.nPosY = {}

  def defineParams(self):
    """
      Define program parameters
    """

    self.addUsageLine('Perform statistical test on a dataset of residual vectors comming from landmark \
      to check for possible patterns, correlations or some other non-random behaviour. ')

    ## params
    self.addParamsLine(' -i <inputMetadaFile>   : coordinate model metadata file path. This file contains the coordinate in slice, \
                        its assigned coordinate 3d and the residual vector between the first and the proyection of the second. This is generated by the \
                        xmipp_tomo_detect_misalignment_trajectory program.\n')

    self.addParamsLine(' -o <outputMetadaFile>   : output residual statistics file path. Location to save the calulated statistics from the residual model \n')


  def readResidInfo(self):
    """
      Read residual information from metadata
    """
    
    mdFilePath = self.getParam('-i')
    mData = xmippLib.MetaData(mdFilePath)

    for objId in mData:
      id = mData.getValue(xmippLib.MDL_FRAME_ID, objId)

      if id in self.residX.keys():
        self.residX[id].append(mData.getValue(xmippLib.MDL_SHIFT_X, objId))
        self.residY[id].append(mData.getValue(xmippLib.MDL_SHIFT_Y, objId))

      else:
        self.residX[id] = [mData.getValue(xmippLib.MDL_SHIFT_X, objId)]
        self.residY[id] = [mData.getValue(xmippLib.MDL_SHIFT_Y, objId)]


  def writeOutputStatsInfo(self, residualStats):
    """
      Write statistical information into metadata
    """

    mdFilePath = self.getParam('-o')
    mData = xmippLib.MetaData()

    for i in range(len(residualStats)):
      id = mData.addObject()
      mData.setValue(xmippLib.MDL_SCORE_BY_ALIGNABILITY, residualStats[i][0], id)
      mData.setValue(xmippLib.MDL_SCORE_BY_ALIGNABILITY_PRECISION, residualStats[i][1], id)
      mData.setValue(xmippLib.MDL_SCORE_BY_ALIGNABILITY_ACCURACY, residualStats[i][2], id)
      mData.setValue(xmippLib.MDL_SCORE_BY_ALIGNABILITY_PRECISION_EXP, residualStats[i][3], id)

      
    mData.write(mdFilePath)

  def generateSideInfo(self):
    """
      Generate residual side information to perform posterior tests
    """
    
    for key in self.residX.keys():
      # Residual info vectors
      self.residSize[key] = len(self.residX[key])

      nPosX = 0
      nPosY = 0

      for i, r in enumerate(self.residX[key]):
        if r > 0:
          nPosX += 1

        if i == 0:
          self.residXAcc[key] = [r]
        else:
          self.residXAcc[key].append(r+self.residXAcc[key][i-1])

      for i, r in enumerate(self.residY[key]):
        if r > 0:
          nPosY += 1

        if i == 0:
          self.residYAcc[key] = [r]
        else:
          self.residYAcc[key].append(r+self.residYAcc[key][i-1])

      self.nPosX[key] = nPosX
      self.nPosY[key] = nPosY

      for i in range(self.residSize[key]):
        if i == 0:
          self.moduleAcc[key] = [sqrt(self.residXAcc[key][i]*self.residXAcc[key][i] + self.residYAcc[key][i]*self.residYAcc[key][i])]
        else:
          self.moduleAcc[key].append(sqrt(self.residXAcc[key][i]*self.residXAcc[key][i] + self.residYAcc[key][i]*self.residYAcc[key][i]))


  def binomialTest(self, nPos, rs):
    """
      Binomial test for sign distribution
    """

    pValue = stats.binom_test(nPos, rs , self.p)

    print("Binomial test p-value: " + str(pValue))

    return pValue

  def fTestVar(self, fStatistic, rs):
    """
      F-test of equality of variances
    """

    pValue = stats.f.cdf(fStatistic, rs-1, rs-1)

    print("F test for variance p-value: " + str(pValue))

    return pValue
  
  def augmentedDickeyFullerTest(self, modAcc):
    """
      Augmented Dickey-Fuller test for random walk
    """

    result = adfuller(modAcc)
    adfStatistic = result[0]
    pValue = result[1]
    criticalValues = result[4]

    print("Augmented Dickey-Fuller test for random walk ADF statistic: " + str(adfStatistic))
    print("Augmented Dickey-Fuller test for random walk p-value: " + str(pValue))
    print("Augmented Dickey-Fuller test for random walk critical values: ")
    for key, value in criticalValues.items():
      print('\t%s: %.3f' % (key, value))
    
    return adfStatistic, pValue, criticalValues

  def run(self):
    print("Running statistical analysis of misalingment residuals...")

    self.readResidInfo()
    self.generateSideInfo()

    # print("resid size")
    # print(self.residSize)
    # print("residx")
    # print(self.residX)
    # print("residY")
    # print(self.residY)
    # print("residXAcc")
    # print(self.residXAcc)
    # print("residAccY")
    # print(self.residYAcc)
    # print("moduleAcc")
    # print(self.moduleAcc)
    # print("nPosX")
    # print(self.nPosX)
    # print("nPosY")
    # print(self.nPosY)

    residualStats = []

    for key in self.residX.keys():
      rs = self.residSize[key]

      pvBinX = self.binomialTest(self.nPosX[key], rs)
      pvBinY = self.binomialTest(self.nPosY[key], rs)

      # Variance distribution matrix
      # sumRadius = 0
      varianceMatrix = np.zeros([2, 2])

      for i in range(len(self.residX[key])):
        rx = self.residX[key][i]
        ry = self.residY[key][i]

        rx2 = rx * rx
        ry2 = ry * ry
        rxy = rx * ry

        # sumRadius += sqrt(rx2+ry2)
        varianceMatrix += np.matrix([[rx2, rxy], [rxy, ry2]])

      print(varianceMatrix)

      [lambda1, lambda2], _ = np.linalg.eig(varianceMatrix)

      pvF = self.fTestVar(lambda1/lambda2, rs)

      adfStatistic, pvADF, cvADF = self.augmentedDickeyFullerTest(self.moduleAcc[key])

      residualStats.append([pvBinX, pvBinY, pvF, pvADF])
    print(residualStats)

    self.writeOutputStatsInfo(residualStats)

  
if __name__ == '__main__':

  exitCode=ScriptTomoResidualStatistics().tryRun()
  sys.exit(exitCode)



